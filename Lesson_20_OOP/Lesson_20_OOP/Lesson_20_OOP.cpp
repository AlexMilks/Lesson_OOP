#include <iostream>
#include "Header.h"
using namespace std;
using namespace my;

//Многофайловые программы
//Причины использования:
//	1) Создание библиотеки классов
//        Есть готовые решение stl, которая содержит множество удобных классов, и методов работы с данными
//	2) Разбиение программы на части
//Когда компоновщик объединяет файлы, определение GlobalVar появляется два раза
//Чтобы убрать все ошибки с этим нужно в main Добавить к int extert
//Она говорит о том что где то в дальнейшем в программе будет определение его, в нашем случае определение находится в file.cpp
//Теперь если мы захотим чтобы, глобальная переменная была в каждом из исходных файлов, нужно добавить слово static рядом с int
//Это сделает, чтобы он виден был только внутри соответствующего файла
//static - имеет несколько значений в функция, если переменная объявленная, живёт на протяжении всей программы
//		   в классах это поле принадлежащие всем объектам класса - или метод, который независит от объекта которым он вызывается(примерно понял)
//         сейчас же просто ограничивает область видимости

//Для того чтобы определить в другом файле функцию, просто пишем там определение, а в main оставляем прототип
//Если мы захотим, чтобы func(), была только внутри файла main, то меняем его, ставим рядом с int static, и пишем определение снизу главного тела

//Константы видны внутри файла, где были объявлены
//Если мы захотим, чтобы она была видна в обоих файлах, нужно определить её через extern const int, а в main убрать = 3

//Классы
//Определение классов должно быть в каждом файле, где мы хотим его использовать
//JustClass::JustFunc() - определение метода
//Библиотеки так же нужно везде подключать
//И там же нужно заного писать класс, это не удобно поэтому надо использовать заголовные файлы

//Заголовочный файл
//Главной причиной использования их является вставка одной и той же информации в разные файлы
//	Заголовочные файлы содержат в себе объявление переменных и функций, а так же могут содержать определение классов
//	Потому что во время определения класса память не выделяется, в отличие от опредений переменных или функций
//И туда помещаем все объявление, которые у нас есть в программе
//Перемещаем extern int GlobalVar;
//А в file.cpp будем оставлять только определение методов, функций или перменных
//Определение класса перемещаем в заголовочный файл
//И перемщаем прототип функции
//Как я понял в заголовочный файл прототипы всего и классы(прототип), в другой .сpp, который не main кладём все определения и методы
//Теперь нам нужно подключить заголовочный файл, везде где нужен, подключаем так #include "Header.h"

//Пространства имён
//Нужны для того, чтобы как то ограничить переменные с одинаковыми именами
//Например я создаю библиотеку и там добавил add(), но она уже есть, но я могу с помощью пространст имён указать
//	к какому пространству имёт принадлежит эта функция тип my::add()
//Создадим своё пространство имён для переменной GlobalVar
//Делается это в заголовке файла
//Чтобы обратиться к GlobalVar, делаем это через оператор ::
//int my::GlobalVar = 7; и теперь везде мы обращаемся только так
//Создадим ещё одно пространство имён
//Для того чтобы не писать этот префикс(Если часто пользуемся), тип my::
//Мы можем написать using namespace my;

//Дополнительно: если убрать std;, то нужно будет самим писать где ввод/вывод как я понял std::


//static int GlobalVar;
//extern const int GlobalVar; 

//Пишем прототип, а определение в другом файле

//static int func();



int main() {
	setlocale(0, "");

	//GlobalVar = 4;
	cout << my::GlobalVar << endl;
	cout << other::GlobalVar << endl;

	//С моим пространством имён, если его объявить в модуле как std;
	cout << GlobalVar << endl;

	cout << func() << endl;

	//Классы

	JustClass JustObj;

	JustObj.JustFunc();

	system("pause");
	return 0;
}

//int func() {
//	return 1;
//}
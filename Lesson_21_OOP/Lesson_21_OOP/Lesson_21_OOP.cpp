#include <iostream>
#include <string>
using namespace std;

const int MAX = 3;
//Шаблоны
//Для чего нужны:
//	Шаблоны позволяют использовать одни и те же функции или классы для обработки данных разных типов

//Шаблоны функций
//Пишем функцию которая складывает два целых числа
//Теперь мы решили что нам нужна ещё одна, но чтобы работала с типом float
//Мы созали три функции, и это не очень, так как если мы будем менять работу в одной из них, то придётся менять и в других
//Воспользуемся шаблоном template - ключевое слово, которое говорит что сейчас будет шаблон

//Шаблоны классов
//Отичий от шаблонов функций мало, используются в основном, для хранения данных разных типов
//В виде списков, стеков, массивов и т.д.
//Начинается всё так же с template

//int add(int a, int b) {
//	return a + b;
//}
//
//float add(float a, float b) {
//	return a + b;
//}
//
//double add(double a, double b) {
//	return a + b;
//}

//Пишем шаблон
//Указваем аргумент шаблона, 
//он представляет собой некое псевдо имя, которое характеризует тот или иной тип данных
//Создадим ещё один аргумент шаблона, newType, и передадим в качестве 3-го аргумента
//Аргумент шаблона можно использовать и внутри функции
template <class type, class newType>
type add(type a, type b, newType text) {
	type sum = a + b;
	cout << text << endl;
	return sum;
	//Можно и так без 34 строки
	//return a + b;
}

//Хранить заданное число элементов любого типа
template <class T>
class Array {
private:
	T arr[MAX];
public:
	//хз почему тут указатель
	Array(T* a) {
		for (int i = 0; i < MAX; i++)
		{
			arr[i] = a[i];
		}
	}

	//Для получения элемента массива по индексу
	//Определение вынесем за пределы класса
	T getElement(int);
};

template <class T>
//Указываем принадлженость классу Array, и с помощью разрешения обращаемся к нужному методу
//В уголовых скобках пишем аргумент шаблона
T Array<T>::getElement(int index) {
	return arr[index];
}

/////////
//Инициализируем обект myArray массивом обекта пользовательского типа данных
class myClass {
private:
	int var1;
	float var2;
public:
	//Сейчас он нужен для того чтобы на 54 строчке не вышла ошибка
	myClass() : var1(0), var2(0) {
	};

	myClass(int v1, float v2) : var1(v1), var2(v2) {
	}

	//Для вывода объекта класса на экран
	void showElement() {
		cout << "var1 = " << var1 << " var2 = " << var2 << endl;
	}
};


int main() {
	setlocale(0, "");

	//int a = 2;
	int b = 3;

	float fa = 4.5;
	float fb = 6.7;

	string sa = "a";
	string sb = "b";

	//cout << add(a, b, "ало") << endl;
	//cout << add(fa, fb) << endl;
	//cout << add(sa, sb) << endl;

	//Для шаблона класса

	int a[] = { 5, 6, 1 };

	//В угловых скобках, поставить какой тип данных будет хранить массив, замещающий аргумент шаблона T
	//Array<int> myArray(a);

	//Выведем первый элемент
	//cout << myArray.getElement(1) << endl;

	//////////
	//Для инициализации обекта myArray массивом обекта пользовательского типа данных

	//Делается это с помощью безымянных объектов
	myClass arr[] = { myClass(8, 3.1), myClass(3, 9.5), myClass(6, 0.1) };

	//Инициализируем им объект myArray
	//С типом данных myClass
	Array<myClass> myArray(arr);

	//Выведем
	myArray.getElement(1).showElement();
	//В итоге получили элемент под индексом 1

	system("pause");
	return 0;
}
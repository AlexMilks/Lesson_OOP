#include <iostream>
using namespace std;

//Виртуальные функции
//В небольших программ могут обойтись без этого, в больших проектах применяются довольно часто
//В одном массиве лежат указатели на разные объекты

//Абстрактные классы - такой объекты которого нельзя создать
//Бывает что классу, не нужны объекты базового класса, 
//и существует он только для того чтобы от него наследовались другие классы
//Для того чтобы класс сделать абстрактным, в нём должна существовать как минимум одна чистая виртуальная функция
//Пишется примерно так virtual void goToWork() = 0
//Теперь он стал абстрактным и мы не можем создавать его объекты

//Деструктор базового класса обязательно должен быть виртуальным, если нет, удалятся только поля принадлежащие базовому классу,
//а у дизайнера могут остаться свои поля.

//Работник
class Employee {
public:
	//Её нужно сделать virtual
	//Компилятор будет обращаться к тем функциям которые нам нужны
	//Иди работай
	//Если = 0, то это не присваивание, а просто говорить компилятору, то что это чисто виртуальная функция
	//Теперь он стал абстрактным и мы не можем создавать его объекты
	virtual void goToWork() = 0 {
		cout << "Работник пошёл работать!" << endl;
	}
};

//Менеджер
class Manager : public Employee {
public:
	void goToWork() {
		cout << "Менеджер пошёл работать!" << endl;
	}
};

//Разработчик
class Developer : public Employee {
public:
	void goToWork() {
		cout << "Разработчик пошёл работать!" << endl;
	}
};

//Дизайнер
class Designer : public Employee {
public:
	void goToWork() {
		cout << "Дизайнер пошёл работать!" << endl;
	}
};

int main() {
	setlocale(0, "");

	Employee* empl;

	//Выделяем память на каждого работника
	Designer* des = new Designer;
	Developer* dev = new Developer;
	Manager* man = new Manager;

	//Указатели на базовые классы совместимы по типу, с указателями на дочерние классы
	empl = des;

	//empl->goToWork();

	empl = dev;

	//empl->goToWork();

	empl = man;

	//empl->goToWork();

	//Если всё так и оставить то ничего работать не будет, надо поставить родителя virtual метод
	//Теперь это позволит нам создать массив указателей

	//Массив из 3 указателей
	Employee* mas[3];

	//Кладём всем работников в массив
	mas[0] = des;
	mas[1] = dev;
	mas[2] = man;

	//В одном массиве лежат указатели на разные объекты
	for (int i = 0; i < 3; i++)
	{
		mas[i]->goToWork();
	}

	//Если в базовом классе виртуальная функция = 0, то объекты нельзя создать
	//Тут будет ошибка
	//Employee empl2;

	system("pause");
	return 0;
}
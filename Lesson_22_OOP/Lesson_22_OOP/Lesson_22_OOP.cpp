#include <iostream>
#include <string>
using namespace std;

//Исключения
//Ошибки которые появлятся в программе
//Возьмём пример из предыдущего урока	

//Сейчас объект ссылается на несуществующий элемент, и выведет мусор
//Для этого нам нужно создать класс исключений, чтобы предупреждать пользователя, что массив не подходит для инициализации объекта
//Создадим его внутри класса Array
//Тело класса оставим пустым, так как пока нам не понадобится не поля не методы
//Теперь чтобы сгенерировать исключение, нужно знать длинну массива, добавим её в конструктор int len
//Исключение делается с помощью слова throw
//Теперь нам нужно создать try, он следит за возникновением исключений
//Дальше за ним идёт обработчик исключений
//Теперь добавим, чтобы было большие информации при ошибки, тип маленькое число, или большое
//Ещё добавили что если обращаемся к несуществующему элементу, такое себе
//В итоге сделали Обработчик ошибок для массива

//Для подбробного изучения обращаться к книге ООП С++ Роберт Лафоре

const int MAX = 3;

class Array {
private:
	int arr[MAX];
public:
	//Ошибки этого типа будут возникать при большом массиве
	class Big {
	};

	//Ошибки этого типа будут возникать при маленьком массиве
	class Small {
	};

	class errorIndex {
	public:
		//Поле которое будет содержать некорректный индекс
		int index;

		//Для инициализации объекта
		errorIndex(int i) : index(i) {

		}

	};

	//Тут не забывать указывать указатель после int*
	Array(int* a, int len) {
		//Если они будут отличаться, то будем генерировать искючение
		//Делается с помощью слова throw
		//Создаём безымянный объект класса Exception
		if (len > MAX) {
			//Это вроде объект
			throw Big();
		}

		if (len < MAX) {
			//Это вроде объект
			throw Small();
		}

		for (int i = 0; i < MAX; i++)
		{
			arr[i] = a[i];
		}
	}

	int getElement(int);
};

int Array::getElement(int index) {
	//Проверка, если не удовлетворяет, то сгенерируем ошибку, и передадим в блок catch, хранящий значение этого индекса
	if (index < 0 || index > MAX) {
		throw errorIndex(index);
	}
	return arr[index];
}

int main() {
	setlocale(0, "");

	//Чтобы посмотреть на ошибки, тут надо уменьшить количество элементов или увеличить, при 3 всё хорошо
	int a[] = { 1, 2, 3 };

	//В этот блок помещается весь тот код, где может появиться ошибка
	//Поэтому поместим всё туда с Array
	try {
		//Возьмём отношение массива к одной его ячейки
		Array arrayObj(a, sizeof(a) / sizeof(int));

		//Чтобы посмотреть на ошибку тут нужно указать несуществующий элемент, сейчас такого элемента несуществует, поэтому будет ошибка
		cout << arrayObj.getElement(-4) << endl;
	}
	//Дальше создаётся обработчик исключений
	//Нужно указать тип обрабатываемой ошибки
	//Все ошибки данного типа будут обрабатываться этим блоком
	//Этот обработчик стал для ошибок типа Big
	catch (Array::Big) {
		cout << "Массив слишком большой!" << endl;
	}

	//Этот обработчик стал для ошибок типа Small
	catch (Array::Small) {
		cout << "Массив слишком маленький!" << endl;
	}

	//Тут нам нужно указать дополнительно имя объекта, которым мы передаём при генерации ошибки
	catch (Array::errorIndex e) {
		cout << "Элемента под индексом " << e.index << " не существует" << endl;
	}

	system("pause");
	return 0;
}

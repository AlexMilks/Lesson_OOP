#include <iostream>
using namespace std;

//Наследование - создание класса, который является наследником
//Производный класс - тот который унаследовал, получает всё что унаследовал и может быть улучшен
//Производный класс содержит {все} свойства, что и базового
//Преимущество в том, что можно использовать существующий код несколько раз
//Так же это позволяет использовать чужие классы, без модификации исходного кода

//Перегрузка функций - изменять действия какой либо функции базового класса, чтобы в наследнике вела себя по другому

//Используем старые класс Counter
class Counter {
	//protected доступен как и в этом классе, так и в наследнике
protected:
	int countz;
public:
	Counter() : countz(0) {
	}

	Counter(int c) : countz(c) {
	}

	int get_count() {
		return countz;
	}

	//Создадим пробную функцию, чтобы перегрузить
	void show_count() {
		cout << "Это объект класс Counter: " << countz << endl;
	}

	Counter operator++ () {
		return Counter(++countz);
	}
};

//Создаём класс наследника
//Через двоиточие, тот от кого наследуется
//Потом спецификтаор доступа public, чтобы открытие и private, чтобы закрытые
//Если указать private, то всё что было в public и protected будут закрыты
//У конструкторов есть нюанс, нужно в наследнике вызвать конструктор базового класса 
class NewCounter : public Counter {
public:
	NewCounter(int c) : Counter(c) {

	}

	//Меняем тут, так как нет конструктора
	Counter operator--() {
		//Ошибка так как он в countez privat
		//Исключение, он доступен в дружественных функциях
		return --countz;
	}

	//Вставляем чисто такую же функцию, меняем тело
	//Работать будет, если вызывать nc, потому что первоначально он ищет метод в NewCounter, а потом только потом в классе родителя
	void show_count() {
		//Если нам вдруг надо вывести в nc базовый метод, то можно сделать так
		//Указываем принадлежность классу Counter, через ::
		Counter::show_count();
		cout << "Это объект класс NewCounter: " << countz << endl;
	}
};

int main() {
	setlocale(0, "");

	Counter c;
	NewCounter nc(4);

	//Ошибка так как у родителя этого метода нет, что есть у наследника
	//c--;

	++c;
	//1
	++nc;
	//1
	--nc;
	//0
	--nc;
	//-1

	cout << c.get_count() << endl;
	cout << nc.get_count() << endl;

	//Сейчас тут выводится что nc объект класса counter, но это не правда, перегрузим функцию
	c.show_count();
	cout << endl;
	nc.show_count();


	system("pause");
	return 0;
}